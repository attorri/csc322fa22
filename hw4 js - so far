

function main() {
  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas});

  const fov = 75;
  const aspect = 2;  // the canvas default
  const near = 0.1;
  var far = 100;
  var camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.z = 5;

  const scene = new THREE.Scene();

  {
    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(-1, 2, 4);
    scene.add(light);
  }

  const geometry = new THREE.Geometry();
  geometry.vertices.push(
  new THREE.Vector3(0, 0,  0),  // 0
  new THREE.Vector3(0, 1,  0),  // 1
  new THREE.Vector3(0,  1,  0),  // 2
  new THREE.Vector3( 1,  1,  0),  // 3
  new THREE.Vector3(0, 0, 1),  // 4
  new THREE.Vector3( 1, 0, 1),  // 5
  new THREE.Vector3(0,  1, 1),  // 6
  new THREE.Vector3( 1,  1, 1),  // 7
);

geometry.faces.push(

//base face
new THREE.Face3(0,1,4),
new THREE.Face3(4,1,5),

//left face
new THREE.Face3(0,4,2),
new THREE.Face3(2,4,6),

//right face
new THREE.Face3(1,5,3),
new THREE.Face3(3,5,7),

//front face
new THREE.Face3(0,1,2),
new THREE.Face3(2,1,3),

//back face
new THREE.Face3(4,5,6),
new THREE.Face3(6,5,7),

//top face
new THREE.Face3(2,3,6),
new THREE.Face3(6,3,7)

);



  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function render(time) {
    time *= 0.001;

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }
/*
    triS.forEach((tri, ndx) => {
      const speed = 0.5 + ndx * .1;
      const rot = time * speed;
      tri.rotation.x = rot;
      tri.rotation.y = rot;
    });
*/
    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
}

main();
